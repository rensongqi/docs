 

golang逃逸分析技术本质上就是在堆和栈区中做选择。编辑器会追踪变量在代码块上的作用域，变量会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，那么它就可以在栈上分配，否则就说它“逃逸”了，必须在堆中分配。

 

示例：

```go
package main

import "fmt"

func main() {
	x := 52
	fmt.Println(x)
}
```



编译命令 go build -gcflags '-m' 会让编译器在编译时输出逃逸分析的结果。

```go
E:\Go\src\test>go build -gcflags="-m" ./main.go
# command-line-arguments
.\main.go:7:13: inlining call to fmt.Println
.\main.go:7:13: x escapes to heap
.\main.go:7:13: []interface {} literal does not escape
<autogenerated>:1: .this does not escape
<autogenerated>:1: .this does not escape
```

我们看到 `x escapes to heap`， 表示它会在运行时在堆空间上动态分配

go build -gcflags参数如下

```go
-m print optimization decisions
-l disable inlining（关闭内联：内联就是把简短的函数在调用它的地方展开）
-n disable optimizations
```

[Go 中的内联优化](https://studygolang.com/articles/28335)

 

引起变量逃逸到堆上的典型情况：

1. 发送指针或带有指针的值到 channel 中。在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。

2. 在一个切片上存储指针或带指针的值。一个典型的例子就是 []*string。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。

3. slice 的背后数组被重新分配了，因为 append 时可能会超出其容量(cap)。slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。

4. 在 interface 类型上调用方法。在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r, 调用 r.Read(b) 会使得 r 的值和切片 b 的背后存储都逃逸掉，所以会在堆上分配。

 

参考文章： [高性能 Go 服务的内存优化(译)](https://www.jianshu.com/p/63404461e520)