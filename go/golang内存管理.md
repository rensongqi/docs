# 1 Golang内存管理简述：

malloc：内存分配（memory allocation） 

1、go可以实现自动的内存管理，在操作系统中，go有两个地方可以分配内存，一个全局堆空间用来动态分配内存，另一个是每个goroutine都有自身的栈空间。

- 栈空间是通过压栈出栈方式自动分配释放的，由系统管理，使用起来高效无感知。

- 堆空间是用以动态分配的，由程序自己管理分配和释放。Go 语言虽然可以帮我们自动管理分配和释放，但是代价也是很高的。

2、go本身更倾向于在栈空间分配内存，因为这块代价比较低，只需要两个CPU操作指令：一是push数据到栈空间完成分配，二是将数据从栈空间释放。但不是所有的数据都在栈空间，栈空间的分配要求变量的生命周期和内存足迹（代表和一个变量相关的所有内存块）可以在编译时确定，否则就会在堆上分配。

3、go的哪些变量是分配到堆上哪些变量是分配到栈上一般会按照数据类型来，go的数据类型大致分为两种类型，一种是值类型，另一种是引用类型。

- 值类型包括：基本数据类型 int、float、bool、string、数组和结构体。

  值类型变量直接存储时，内存通常在栈中分配（golang中有逃逸分析，所以有可能值类型还会在堆中），Go编辑器会根据变量使用多长时间来决定在哪，比如一个变量生存时间比较长，那可能就放在堆区，还比如有一个值类型在其他函数中可能也会用到，那么这个值类型就有可能会在堆区存放

- 引用类型：指针、切片、map、channel管道、interface等都是引用类型。

  引用类型变量存储的是一个内存地址，这个地址对应的空间才是真正存储数据（值），内存通常在堆上分配，当没有任何变量引用这个地址时，该地址对应的数据空间就成为一个垃圾，由GC来回收。

 

# 2 内存命中率

假设在 n 次内存访问中，出现命中的次数是 m，那么 m / n * 100% 就表示命中率，这是衡量内存管理程序好坏的一个很重要的指标。

如果物理内存不足了，数据会在主存和磁盘之间频繁交换，命中率很低，性能出现急剧下降，我们称这种现象叫内存颠簸。这时你会发现系统的 swap 空间利用率开始增高， CPU 利用率中 iowait 占比开始增高。

大多数情况下，只要物理内存够用，页命中率不会非常低，不会出现内存颠簸的情况。因为大多数程序都有一个特点，就是局部性。

**局部性就是说被引用过一次的存储器位置，很可能在后续再被引用多次；而且在该位置附近的其他位置，也很可能会在后续一段时间内被引用。**

计算机使用一级级的缓存来提升性能，归根结底就是利用了局部性的特征，如果没有这个特性，一级级的缓存不会有那么大的作用。所以一个局部性很好的程序运行速度会更快。

局部性好的程序，可以提高缓存命中率，这对底层系统的内存管理是很友好的，可以提高程序的性能。CPU Cache 层面的低命中率导致的是程序运行缓慢，内存层面的低命中率会出现内存颠簸，出现这种现象时你的服务基本上已经瘫痪了。Go 语言的内存管理是参考 tcmalloc 实现的，它其实就是利用好了 OS 管理内存的这些特点，来最大化内存分配性能的。



# 3 CPU里的寄存器

其实就是我们常说的：Cache，有1级 和 2级和3级。L1容量比较小，L2集成在主板上，所使用的为静态RAM，所以L2容量会多一些。

L1是集成在CPU内部的寄存器(L1与CPU 同步），访问它速度自然很快，但容量比较小，L1 64K L2现在最高的就2MB，这显然是不够的，所以我们都需要扩展它，内存(DDR RAM)就是扩展的“寄存器”，它的访问速度就比 Cache 速度慢！CPU 在运行某计算时，它会把使用频率高的数据放到L1，L2，把不常用的数据保存在RAM中，需要访问的时候再读入Cache，当然相比之下硬盘的速度就更低。