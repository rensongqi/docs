# Linux 处理僵尸进程

**僵尸进程：** 一个子进程在其父进程没有调用wait()或waitpid()的情况下退出。这个子进程就是僵尸进程。如果其父进程还存在而一直不调用wait，则该僵尸进程将无法回收，等到其父进程退出后该进程将被init回收。

**孤儿进程：** 一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。（在一个tty执行了后台命令，关闭tty之后该进程会被托管至1号进程收养）。僵尸进程将会导致资源浪费，而孤儿则不会。

在linux系统中，当用ps命令观察进程的执行状态时，经常看到某些进程的状态栏为defunct，这就是所谓的“僵尸”进程。“僵尸”进程是一个早已死亡的进程，但在进程表（processs table）中仍占了一个位置（slot）。由于进程表的容量是有限的，所以，defunct进程不仅占用系统的内存资源，影响系统的性能，而且如果其数目太多，还会导致系统瘫痪。



## **僵尸进程的产生原因**

我们知道，每个进程在进程表里都有一个进入点（entry），核心程序执行该进程时使用到的一切信息都存储在进入点。当用ps命令察看系统中的进程信息时，看到的就是进程表中的相关数据。

所以，当一个父进程以fork()系统调用建立一个新的子进程后，核心进程就会在进程表中给这个子进程分配一个进入点，然后将相关信息存储在该进入点所对应的进程表内。这些信息中有一项是其父进程的识别码。

而当这个子进程结束的时候（比如调用exit命令结束），其实他并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构（系统调用exit的作用是使进程退出，但是也仅仅限于一个正常的进程变成了一个僵尸进程，并不能完全将其销毁）。此时原来进程表中的数据会被该进程的退出码（exit code）、执行时所用的CPU时间等数据所取代，这些数据会一直保留到系统将它传递给它的父进程为止。由此可见，defunct进程的出现时间是在子进程终止后，但是父进程尚未读取这些数据之前。

此时，该僵尸子进程已经放弃了几乎所有的内存空间，没有任何可执行代码，也不能被调度，仅仅在进程列表中保留一个位置，记载该进程的退出状态信息供其他进程收集，除此之外，僵尸进程不再占有任何存储空间。他需要他的父进程来为他收尸，如果他的父进程没有安装SIGCHLD信号处理函数调用wait 或 waitpid() 等待子进程结束，也没有显式忽略该信号，那么它就一直保持僵尸状态，如果这时候父进程结束了，那么init进程会自动接手这个子进程，为他收尸，他还是能被清除掉的。但是如果父进程是一个循环，不会结束，那么子进程就会一直保持僵尸状态，这就是系统中为什么有时候会有很多的僵尸进程。


## 僵尸进程处理

[孤儿进程和僵尸进程的概念及进程回收](https://cloud.tencent.com/developer/article/1946590)


1. 查看系统是否有僵尸进程

   使用Top命令查找，当zombie前的数量不为0时，即系统内存在相应数量的僵尸进程。

2. 定位僵尸进程

   使用命令`ps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'`定位僵尸进程以及该僵尸进程的父进程

   僵尸进程ID：3457，父进程ID：3425

   僵尸进程ID：3533，父进程ID：3511

   > 参数解读
   >
   > ps -A -ostat,ppid,pid,cmd |grep -e '^[Zz]'
   >
   > -A 参数列出所有进程
   >
   > -o 自定义输出字段 stat（状态）、ppid（进程父id）、pid（进程id）、cmd（命令）
   >
   > 因为状态为z或者Z的进程为僵尸进程，所以我们使用grep抓取stat状态为zZ进程

3. 使用Kill -HUP 僵尸进程ID来杀死僵尸进程，往往此种情况无法杀死僵尸进程，此时就需要杀死僵尸进程的父进程

   kill -HUP 僵尸进程父ID

   然后使用上面的语句查询该僵尸进程是否被杀死

4. 如果父进程也杀不死，就只能重启了。


## 预防僵尸进程

以上介绍的只是在发现了僵尸进程之后，如何去杀死它。那么，有同学可能会说了，这个是治标不治本的。真正的办法是，不让它产生，问题才能彻底解决。OK，那我们就来介绍一下，如何预防僵尸进程的产生。

- 在父进程创建子进程之前，就向系统申明自己并不会对这个子进程的exit动作进行任何关注行为，这样的话，子进程一旦退出后，系统就不会去等待父进程的操作，而是直接将该子进程的资源回收掉，也就不会出现僵尸进程了。具体的办法就是，在父进程的初始化函数中，调用这个函数：signal(SIGCHLD,SIG_IGN)；
- 如果上述语句没来得及调用，也有另外一个办法。那就是在创建完子进程后，用waitpid等待子进程返回，也能达到上述效果；
- 如果上述两个办法都不愿意采用，那还有一招：在父进程创建子进程的时候，连续调用两次fork()，而且使紧跟的子进程直接退出，使其孙子进程成为孤儿进程，从而init进程将代替父进程来接手，负责清除这个孤儿进程。于是，父进程就无需进行任何的清理行为，系统会自动处理；