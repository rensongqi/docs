排序是将一组数据，依照指定的顺序进行排列的过程，常见的排序有如下几种

## 1 冒泡排序

1、冒泡排序第一版本，原始冒泡排序

```go
func maoPao1(nums []int) []int {
	for i := 0; i < len(nums)-1; i++ {
		for j := 0; j < len(nums)-i-1; j++ {
			if nums[j] > nums[j+1]{
				nums[j], nums[j+1] = nums[j+1], nums[j]
			}
		}
	}
	return nums
}
```

2、冒泡排序第二版本，当能判断出排序已经有序，则不进行循环

```go
func maoPao2(nums []int) []int {
	for i := 0; i < len(nums)-1; i++ {
		isSorted := true
		for j := 0; j < len(nums)-i-1; j++ {
			if nums[j] > nums[j+1]{
				nums[j], nums[j+1] = nums[j+1], nums[j]
				//因为有元素进行交换，所以不是有序的，标记变为false
				isSorted = false
			}
		}
		if isSorted {
			break
		}
	}
	return nums
}
```

3、冒泡排序第三版本，内层循环每循环一次，数组最后有序的数就会增加一位，那么可以在设置一个无序边界，每次内层循环只需要循环到这个内层边界即可 sortBorder

```go
func maoPao3(nums []int) []int {
	//记录最后一次交换的位置，这个值需要赋值给sortBorder
	lastExchangeIndex := 0
	//无序数列的边界
	sortBorder := len(nums)-1
	for i := 0; i < len(nums)-1; i++ {
		isSorted := true
		for j := 0; j < sortBorder; j++ {
			if nums[j] > nums[j+1]{
				nums[j], nums[j+1] = nums[j+1], nums[j]
				//因为有元素进行交换，所以不是有序的，标记变为false
				isSorted = false
				//更新最后一次交换元素的位置
				lastExchangeIndex = j
			}
		}
		sortBorder = lastExchangeIndex
		if isSorted {
			break
		}
	}
	return nums
}
```

4、冒泡排序第四版，鸡尾酒排序，以前几次版本算法的每一轮都是从左到右来比较元素，进行交换。鸡尾酒排序是双向的，每次进行一次遍历，根据遍历次数的奇偶，来决定是从左还是右进行元素置换。鸡尾酒排序能发挥出来的优势很明显，适合大部分元素已经有序的情况下 ，缺点就是代码量几乎翻了一倍

```go
func maoPao4(nums []int) []int {
	for i := 0; i < len(nums)-1; i++ {
		isSorted := true
		//奇数轮，从左到右进行交换
		for j := i; j < len(nums)-i-1; j++ {
			if nums[j] > nums[j+1]{
				nums[j], nums[j+1] = nums[j+1], nums[j]
				isSorted = false
			}
		}
		if isSorted {
			break
		}
		isSorted = true
		//偶数轮，从右至左进行交换
		for j := len(nums)-i-1; j > i ; j-- {
			if nums[j] < nums[j-1]{
				nums[j], nums[j-1] = nums[j-1], nums[j]
				isSorted = false
			}
		}
		if isSorted {
			break
		}
	}
	return nums
}
```



## 2 快速排序



## 3 堆排序



## 4 计数排序



## 5 桶排序



